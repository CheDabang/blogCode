<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>


</body>

</html>
<script>
    // let food = "煎饼果子"
    // let drink = "热豆浆"
    // let menu = null
    // let menu = food + drink
    // console.log(menu) // 煎饼果子热豆浆
    // food = '炸鸡汉堡'
    // drink = '快乐水'
    // console.log(menu) // 煎饼果子热豆浆
    // 很明显控制台输出两端重复文字，煎饼果子热豆浆
    // 想要变化，那么就得重新赋值。
    // menu = food + drink
    // console.log(menu) // 炸鸡汉堡快乐水
    // 这个时候，我定义一个方法
    // let target = null
    // target = () => {
    //     menu = food + drink
    // }
    // food = '炸鸡汉堡2号'
    // drink = '快乐水2号'
    // target()
    // console.log(menu) // 输出2号
    // 这样就是每一次数据更新之后，触发相应的target事件。

 

    let storge = []; //用来存储更多的target

    // function record(target) {
    //     storge.push(target)
    // }
    // console.log(storge)

    // function replay() {
    //     storge.forEach(run => run())
    // }
    // record(target)
    // replay()
    // console.log(menu)
    // food = '炸鸡汉堡'
    // drink = '快乐水'
    // replay()
    // console.log(menu)
    // 单纯这么搞，貌似有点麻烦
    // 再来加强版,把这个整合一下。

    class Dep {
        constructor() {
            this.subs = []
        }
        // 收集依赖
        depend(sub) {
            if (sub && !this.subs.includes(sub)) {  // 做一个判断
                this.subs.push(sub)
            }
        }

        notify() {
            console.log("下雨啦，收衣服啦！", this.subs)
            this.subs.forEach(sub => sub()) // 运行我们的target
        }
    }
    // let dep = new Dep()
    // dep.depend(target)
    // target()
    // console.log(menu)
    // food = '炸鸡汉堡'
    // drink = '快乐水'
    // dep.notify()
    // console.log(menu)
    // 后面如果有新的依赖，所以还是新命名targetMax，然后dep添加，更新数据数据数据的，再通知变化。
    // let dep = new Dep()
    // function watcher(myFun) {
    //     target = myFun
    //     dep.depend(target)
    //     target()
    //     target = null
    // }
    // watcher(target = () => {
    //     menu = food + drink
    // })
    // console.log(menu)
    // food = '炸鸡汉堡'
    // drink = '快乐水'
    // dep.notify()
    // console.log(menu)
    // 但是每次都需要更新数据，还需要我这边手工消息通知太麻烦，那么就得思考对象有什么属性
    // 能够直接更新
    // 这个时候需要用到属性Object.defindProperty

    // 之后就是通过一个for循环，依次为每个属性添加Objec.defindProperty
    let data = {
        food: '煎饼果子',
        drink: '热豆浆'
    }
    Object.keys(data).forEach(key => {
        let value = data[key]
        let dep = new Dep()

        Object.defineProperty(data, key, {
            get() {
                dep.depend(target)
                return value
            },
            set(newVal) {
                console.log(newVal)
                value = newVal
                dep.notify()
            }
        })
    })
    function watcher(myFun) {
        target = myFun
        // dep.depend(target)
        target()
        target = null
    }
    watcher(() => {
        console.log('watcher')
        data.menu = data.food + data.drink
    })
    console.log(data.menu)
    data.food = "炸鸡汉堡"
    console.log(data.menu)
    // 昨天的忘记同步的脑壳疼
</script>