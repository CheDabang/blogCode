<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <div id="app">{{test.name}}</div>
</body>

</html>
<script>
    /**
     * 练习一简单预热了Object.defineProperty, 那么接下来就实现练习一里面的两个需求点
     * 1、当目标的调用的时候，收集记录在册。
     * 2、修改新数据的时候通知
    */
function defineReactive(data, key, val) {
    observe(val); // 递归遍历所有子属性
    Object.defineProperty(data, key, {
        enumerable: true,
        configurable: true,
        get: function() {
            return val;
        },
        set: function(newVal) {
            val = newVal;
            console.log('属性' + key + '已经被监听了，现在食物为：“' + newVal.toString() + '”');
        }
    });
}
 
function observe(data) {
    console.log(data)
    if (!data || typeof data !== 'object') {
            return;
    }
    Object.keys(data).forEach(function(key) {
            defineReactive(data, key, data[key]);
    });
};
 
var foodList = {
    food1: {
        name: '暂时没有名字'
    },
    food2: '煎饼果子'
};
observe(library);
foodList.book1.name = '鸡腿'; // 属性name已经被监听了，现在值为：“鸡腿”
foodList.book2 = '煎饼果子加鸡蛋';  // 属性book2已经被监听了，现在值为：“煎饼果子加鸡蛋”

// observe就相当于一个监听器了, 对于每个对象的属性进行相应的监听。那么问题来了，我特么有好几个呢？
// 如果我有很多监听器，这时候就需要一个容器Dep来存储记录

/*  ES5版本容器Dep
function Dep () {
    this.subs = [];
}
Dep.prototype = {
    addSub: function(sub) {
        this.subs.push(sub);
    },
    notify: function() {
        this.subs.forEach(function(sub) {
            sub.update();
        });
    }
};
*/

// ES6版本容器Dep
class Dep {
    constructor () {
        this.subs = []
    }
    // 收集依赖
    addSub (sub) {
        this.subs.push(sub)
    }
    // 通知给观察者
    notify () {
        this.subs.forEach(function(sub){
            sub.update()
        })
    }
}

</script>